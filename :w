use {
    flate2::read::GzDecoder,
    octocrab::models::{repos::Release, ReleaseId},
    reqwest::{Client, IntoUrl, Response},
    serde::{Deserialize, Serialize},
    std::{
        collections::HashMap,
        fmt, fs,
        io::{SeekFrom, Write},
        path::{Path, PathBuf},
        sync::Arc,
    },
    tar::Archive,
    tempfile::{Builder, TempDir},
    tokio::{
        fs::{create_dir, read_dir, read_to_string, try_exists, File},
        io::AsyncWriteExt,
        sync::RwLock,
    },
};

pub type Settings = Arc<RwLock<SettingsRaw>>;

#[derive(Deserialize, Serialize, Default, Debug, Clone, PartialEq)]
pub struct TimerSettings {
    #[serde(default)]
    pub disabled: bool,
}

impl TimerSettings {
    fn disable(&mut self) {
        self.disabled = true;
    }
    fn enable(&mut self) {
        self.disabled = false;
    }
    pub fn toggle(&mut self) {
        self.disabled = !self.disabled;
    }
}

#[derive(Deserialize, Serialize, Default, Debug, Clone, PartialEq)]
pub struct DownloadData {
    pub owner: String,
    pub repository: String,
    last_release_id: Option<String>,
    installed_path: Option<PathBuf>,
    #[serde(skip)]
    pub needs_update: NeedsUpdate,
}

#[derive(PartialEq, Clone, Debug, Default)]
pub enum NeedsUpdate {
    #[default]
    Unknown,
    Known(bool, String),
}

impl fmt::Display for NeedsUpdate {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        use NeedsUpdate::*;
        match &self {
            Unknown => write!(f, "Unknown"),
            Known(needs, id) if *needs => write!(f, "Update {} available", id),
            Known(_needs, _id) => write!(f, "Update unavailable"),
        }
    }
}

impl DownloadData {
    fn new(owner: &str, repository: &str) -> Self {
        Self {
            owner: owner.to_string(),
            repository: repository.to_string(),
            last_release_id: Default::default(),
            installed_path: Default::default(),
            needs_update: Default::default(),
        }
    }

    fn suggested_sources() -> impl Iterator<Item = Self> {
        let hardcoded_sources = [("QuitarHero", "Hero-Timers")];
        hardcoded_sources
            .into_iter()
            .map(|(owner, repository)| Self::new(owner, repository))
    }

    pub async fn check_for_updates(&mut self) {
        self.needs_update = self.needs_update().await;
    }

    pub async fn needs_update(&self) -> NeedsUpdate {
        use NeedsUpdate::*;
        if let Ok(remote_release_id) = self.get_latest_id().await {
            if let Some(release_id) = &self.last_release_id {
                Known(*release_id != remote_release_id, remote_release_id)
            } else {
                Known(true, remote_release_id)
            }
        } else {
            Unknown
        }
    }

    async fn get_latest_id(&self) -> anyhow::Result<String> {
        Ok(self.get_latest_release().await?.tag_name)
    }

    async fn get<U: IntoUrl>(url: U) -> anyhow::Result<Response> {
        let name = env!("CARGO_PKG_NAME");
        let authors = env!("CARGO_PKG_AUTHORS");
        let user_agent = format!("{} by {}", name, authors);
        let client = Client::builder().user_agent(user_agent).build()?;
        Ok(client.get(url).send().await?)
    }

    pub async fn get_latest_release(&self) -> anyhow::Result<Release> {
        Ok(octocrab::instance()
            .repos(&self.owner, &self.repository)
            .releases()
            .get_latest()
            .await?)
    }

    pub async fn download_latest(&mut self, addon_dir: &Path) -> anyhow::Result<()> {
        let release = self.get_latest_release().await?;
        if let Some(download_url) = release.tarball_url {
            let latest_release_id = release.id;
            let response = Self::get(download_url);
            let finaldir_name = format!("taimi_{}_{}", self.owner, self.repository);
            let tempdir_name = format!("{}_{}", finaldir_name, latest_release_id);
            let tempfile_name = "archive.tar.gz";
            let mut tmp_dir = Builder::new()
                .prefix(&tempdir_name)
                .rand_bytes(5)
                .keep(true)
                .tempdir()?;
            log::info!(
                "Temporary directory for {:?} is {:?}",
                finaldir_name,
                tmp_dir
            );
            let dest_path = tmp_dir.path().join(tempfile_name);
            let mut dest = File::create(&dest_path)?;
            let content = response.bytes().await?;
            dest.write_all(&content)?;
            dest.rewind()?;
            let tar = GzDecoder::new(dest);
            let mut archive = Archive::new(tar);
            archive.unpack(&dest_path)?;
            let folder_to_unpack = read_dir(tmp_dir)?;
            for path in folder_to_unpack {
                let path = path?.path();
                if let Some(file_name) = path.file_name() {
                    let file_name = file_name.to_string_lossy().to_lowercase();
                    let owner = self.owner.to_lowercase();
                    let repository = self.repository.to_lowercase();
                    let checks = file_name.contains(&owner) && file_name.contains(&repository);
                    if path.is_dir() && checks {
                        fs::copy(path.join("timers"), addon_dir)?;
                    }
                }
            }
            self.installed_path = Some(addon_dir.join("timers"));
            self.last_release_id = Some(latest_release_id.to_string());
        }
        Ok(())
    }
}

#[derive(Deserialize, Serialize, Default, Debug, Clone)]
pub struct SettingsRaw {
    #[serde(skip)]
    addon_dir: PathBuf,
    #[serde(default)]
    pub timers: HashMap<String, TimerSettings>,
    #[serde(default)]
    pub downloaded_releases: Vec<DownloadData>,
}

impl SettingsRaw {
    pub fn get_paths(&self) -> Vec<&PathBuf> {
        self.downloaded_releases
            .iter()
            .filter_map(|dd| dd.installed_path.as_ref())
            .collect()
    }

    pub fn toggle_timer(&mut self, timer: String) {
        let entry = self.timers.entry(timer.clone()).or_default();
        entry.toggle();
        let irrelevant = entry == &Default::default();
        if irrelevant {
            self.timers.remove(&timer);
        }
        let _ = self.save(&self.addon_dir);
    }
    pub fn disable_timer(&mut self, timer: String) {
        if let Some(entry_mut) = self.timers.get_mut(&timer) {
            entry_mut.disable();
        } else {
            self.timers.insert(timer, TimerSettings { disabled: true });
        }
        let _ = self.save(&self.addon_dir);
    }
    pub fn enable_timer(&mut self, timer: String) {
        if let Some(entry_mut) = self.timers.get_mut(&timer) {
            entry_mut.enable();
        } else {
            self.timers.insert(timer, TimerSettings::default());
        }
        let _ = self.save(&self.addon_dir);
    }

    pub async fn download_latest(&mut self, owner: String, repository: String) {
        for release in self
            .downloaded_releases
            .iter_mut()
            .filter(|dd| dd.owner == owner && dd.repository == repository)
        {
            match release.download_latest(&self.addon_dir).await {
                Ok(_) => (),
                Err(err) => log::error!("{}", err),
            }
        }
        let _ = self.save(&self.addon_dir);
    }

    pub async fn new(addon_dir: &Path) -> Self {
        Self {
            addon_dir: addon_dir.to_path_buf(),
            timers: Default::default(),
            downloaded_releases: DownloadData::suggested_sources().collect(),
        }
    }
    pub async fn load(addon_dir: &Path) -> anyhow::Result<Self> {
        let settings_path = addon_dir.join("settings.json");
        if try_exists(&settings_path).await? {
            let file_data = read_to_string(settings_path).await?;
            return Ok(serde_json::from_str::<Self>(&file_data)?);
        }
        Ok(Self::new(addon_dir).await)
    }

    pub async fn load_default(addon_dir: &Path) -> Self {
        match SettingsRaw::load(addon_dir).await {
            Ok(settings) => settings,
            Err(err) => {
                log::error!("Settings load error: {}", err);
                Self::new(addon_dir).await
            }
        }
    }

    pub async fn load_access(addon_dir: &Path) -> Settings {
        Arc::new(RwLock::new(Self::load_default(addon_dir)).await)
    }

    pub async fn save(&self, addon_dir: &Path) -> anyhow::Result<()> {
        let settings_path = addon_dir.join("settings.json");
        let settings_str = serde_json::to_string(self)?;
        let mut file = File::create(settings_path).await?;
        file.write_all(settings_str.as_bytes()).await?;
        Ok(())
    }
}
